# 목차📚
[1. 배열-1](#배열part-1). 
[2. 배열-2](#배열part-2).   
[3. 객체](#객체object).   
[4. JSON](#json). 
## 배열_Part 1
- .length : 배열의 길이를 반환
```jsx
const arr = ['A','B', 'C']
console.log(arr.length) //3
```

- .at() : 대상 배열을 인덱싱, 음수 값 사용시 뒤에서 부터 인덱싱
```jsx
const arr = ['A','B', 'C']
// A 
console.log(arr[0])
console.log(arr.at(0))
// C -> at 메서드가 대괄호 표기법 보다 조금 더 간결한 코드를 제공
console.log(arr[arr.length-1])
console.log(arr.at(-1)) 
```

- .concat() : 대상 배열과 주어진 배열을 병합한 새로운 배열을 반환
```jsx
const arr1 = ['A','B','C']
const arr2 = ['D','E','F']


const arr3 = arr1.concat(arr2)
// 🚨 전개 연산자를 사용하여 concat과 동일한 결과 출력 가능
const arr3 = [...arr1 , ...arr2]

console.log(arr1)
console.log(arr2) 
console.log(arr3) // (6) ['A', 'B', 'C', 'D', 'E', 'F']
```

- every() : 대상 배열의 모든 요소가 콜백 테스트에서 참(Truthy Data) 를 반환하는지 확인
```jsx
const arr = [1, 2, 3, 4]
const isValid = arr.every(item => item < 5)

console.log(isValid) // true
```

- filter(): 주어진 콜백 테스트를 통과(Truthy Data return)하는 모든 요소(element, item)를 새로운 배열로 반환  
(만약, 모든 요소가 테스트를 통과하지 못한다면 빈 배열을 반환)

```jsx
const numbers = [1, 20, 7, 9 ,104, 0 ,50]
const filteredNumbers = numbers.filter(number => number < 30)

console.log(filteredNumbers) // (5) [1, 20, 7, 9, 0]
```
  - Case
  ```jsx
    // 으른 판독기
    const users = [
    {name: "Neo", age: 85},
    {name: "Amy", age: 22},
    {name: "Lewis", age: 11}
    ]

    const adults = users.filter(user => {
      return user.age >= 19
    })

    console.log(adults)
  ```

## 배열_Part 2
- .find() : 대상 배열에서 콜백 테스트를 통과하는 첫번째 요소를 반환
```jsx
const arr = [5, 8, 130, 12, 44, 160]
const founditem = arr.find(item => item > 10)

console.log(founditem) //130 -> 130이 첫번째이기 때문에 130만 출력

```
  - Case 2
    ```jsx
    const users = [
    {name: 'Cho', score: 85},
    {name: 'Kim', score: 72},
    {name: 'Park', score: 92},
      {name: 'Lee',score:100}
    ]

    const checkScore = users.find(user => user.score >= 90)
    console.log(checkScore) //{name: 'Park', score: 92}
    ```

- .findIndex(): 대상 배열에서 콜백 테스트를 통과하는 첫번째 요소의 "인덱스"를 반환
```jsx
// .find() 와 동일한 배열
const checkScore = users.findIndex(user => user.score >= 90)
console.log(checkScore) // 2
```

- .flat() : 대상 배열의 모든 하위 배열을 지정된 깊이(Depth)까지 이어붙인 새로운 배열을 생성  
깊이 기본값 = 1
```jsx
// 하위 배열의 [3,4]의 리터럴을 날리고 새로운 배열을 리턴 
const arr =  [1,2, [3,4]]
console.log(arr.flat()) // [1, 2, 3, 4]

// Case 2
const arr =  [1,2, [3,4,[5,6]]]

console.log(arr.flat()) // depth default = 1, [1, 2, 3, 4, Array(2)]
console.log(arr.flat(2)) // 2를 인수로 전달하여 depth 2로 설정 [1, 2, 3, 4, 5, 6]
console.log(arr.flat(Infinity)) // Infinity 객체 활용 -> 가장 깊은 하위 배열까지, [1, 2, 3, 4, 5, 6]
```

- .foreach() : 대상 배열의 길이만큼 주어진 콜백을 실행
```jsx
const arr = ['A','B','C','D']
// forEach -> 중간에 반복 종료 불가
arr.forEach(item => console.log(item)) // A B C D
// for 반복문 -> 조건문통해 중간에 반복 종료 가능
for(let i = 0; i < arr.length; i+= 1) {
  console.log(arr[i]) // A B C D 
}
```

- .includes() : 대상 배열이 특정 요소를 포함하고 있는지 확인
```jsx
const arr = [1,2,3]
console.log(arr.includes(2)) // true
console.log(arr.includes(4)) // false

// 대소문자 구분 주의
const fruits = ['Apple','Banana','Cherry']
console.log(fruits.includes('cherry')) // false
```
  - Case2
    ```jsx
    const users = [
    {name: 'Kim', age: 44},
    {name: 'Park', age: 64},
    {name: 'Cho', age: 24}
    ]
    // 🚨 참조형 -> 객체 ,배열 ,함수 , "생김새가 같아도 다른 데이터 일 수 있다."
    console.log(users.includes({name: 'Kim', age: 44})) // false
    const neo = users[0]
    console.log(users.includes(neo)) // true
    ```

- 

## 객체(Object)

## JSON
